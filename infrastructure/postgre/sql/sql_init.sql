-- feeds table with URLs, subscribers and stats
CREATE TABLE feeds (
    id BIGINT PRIMARY KEY generated by default as identity,
    url VARCHAR( 500 ) UNIQUE,
	title VARCHAR( 500 ),
	icon VARCHAR( 500 ) DEFAULT '',
	fetch_interval_minutes SMALLINT NOT NULL DEFAULT 5,
	last_fetch_ts INT NOT NULL DEFAULT 0,
	last_non_empty_fetch INT NOT NULL DEFAULT 0,
	next_fetch_ts INT NOT NULL DEFAULT 0,
	last_error TEXT DEFAULT '',
	last_error_ts INT NOT NULL DEFAULT 0,
	empty_fetches INT NOT NULL DEFAULT 0,
	subsequent_stable_fetch_intervals INT NOT NULL DEFAULT 0,
	subsequent_errors_counter INT NOT NULL DEFAULT 0,
	total_fetches INT NOT NULL DEFAULT 0,
	total_errors INT NOT NULL DEFAULT 0,
	normal_subscribers INT NOT NULL DEFAULT 0,
	premium_subscribers INT NOT NULL DEFAULT 0,
	stories_per_day TEXT DEFAULT '{}',
    stories_per_hour TEXT DEFAULT '{}',
    stories_per_month TEXT DEFAULT '{}'
);

CREATE INDEX next_fetch_ts ON feeds( next_fetch_ts ASC );
CREATE INDEX rss_fetch_conditions ON feeds (normal_subscribers ASC, premium_subscribers ASC, next_fetch_ts ASC, subsequent_errors_counter DESC );
CREATE INDEX errors_check ON feeds ( subsequent_errors_counter DESC, last_error_ts ASC );
CREATE INDEX url ON feeds USING HASH ( url );

-- functions to update stats on the given feed
-- recursive JSON merge
CREATE OR REPLACE FUNCTION jsonb_merge_recurse(orig jsonb, delta jsonb)
RETURNS jsonb LANGUAGE SQL AS $$
    SELECT
        jsonb_object_agg(
            COALESCE(keyOrig, keyDelta),
            CASE
                WHEN valOrig isnull THEN valDelta
                WHEN valDelta isnull THEN valOrig
                WHEN (jsonb_typeof(valOrig) <> 'object' OR jsonb_typeof(valDelta) <> 'object') THEN valDelta
                ELSE jsonb_merge_recurse(valOrig, valDelta)
            END
        )
    FROM jsonb_each(orig) e1(keyOrig, valOrig)
    FULL JOIN jsonb_each(delta) e2(keyDelta, valDelta) ON keyOrig = keyDelta
$$;

-- updates stories per day, usage: SELECT inc_stories_per_day( 'some_rss_feed', '2', '19', '2023', 14 )
CREATE OR REPLACE FUNCTION inc_stories_per_day( feed_url text, day_of_week text, week_of_year text, year_num text, inc_by integer ) RETURNS bool AS $$
BEGIN
	UPDATE feeds SET stories_per_day = jsonb_merge_recurse( stories_per_day::jsonb, ('{ "' || day_of_week || '" : { "' || week_of_year || '" : { "' || year_num || '" : ' || ( COALESCE( stories_per_day::jsonb->day_of_week->week_of_year->year_num::text,'0')::int + inc_by)::text ||' } } }')::jsonb ) WHERE url = feed_url;
	RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- updates stories per month, usage: SELECT inc_stories_per_month( 'some_rss_feed', '11', '2023', 10 )
CREATE OR REPLACE FUNCTION inc_stories_per_month( feed_url text, month_num text, year_num text, inc_by integer ) RETURNS bool AS $$
BEGIN
	UPDATE feeds SET stories_per_month = jsonb_merge_recurse( stories_per_month::jsonb, ('{ "' || month_num || '" : { "' || year_num || '" : ' || ( COALESCE( stories_per_month::jsonb->month_num->year_num::text,'0')::int + inc_by)::text ||' } }')::jsonb ) WHERE url = feed_url;
	RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- updates stories per hour, usage: SELECT inc_stories_per_hour( 'some_rss_feed', '18', '129', '2023', 7 )
CREATE OR REPLACE FUNCTION inc_stories_per_hour( feed_url text, hour_num text, day_of_year text, year_num text, inc_by integer ) RETURNS bool AS $$
BEGIN
	UPDATE feeds SET stories_per_hour = jsonb_merge_recurse( stories_per_hour::jsonb, ('{ "' || hour_num || '" : { "' || day_of_year || '" : { "' || year_num || '" : ' || ( COALESCE( stories_per_hour::jsonb->hour_num->day_of_year->year_num::text,'0')::int + inc_by)::text ||' } } }')::jsonb ) WHERE url = feed_url;
	RETURN TRUE;
END;
$$ LANGUAGE plpgsql;